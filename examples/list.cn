union list_t (
  t : type
) [ null_t cons_t ]

class null_t (
  t : type
)

class cons_t (
  t : type
  car : t
  cdr : list_t (t)
)


list_length : (list_t (:t)) -> nat_t
list_length (list) = {
  list case {
    null_t => zero_c
    cons_t => succ_c (list_length (list.cdr))
  }
}


list_append : (list_t (t) list_t (t)) -> list_t (t)
list_append (ante succ) = {
  ante case {
    null_t => succ
    cons_t => cons_c (ante.car list_append (ante.cdr succ))
  }
}


list_map : ((a) -> b list_t (a)) -> list_t (b)
list_map (fun list) = {
  list case {
    null_t => list
    cons_t => cons_c (
      fun (list.car)
      list_map (fun list.cdr))
  }
}


list_remove_first : (t list_t (t)) -> list_t (t)
list_remove_first (x list) = {
  list case {
    null_t => list
    cons_t => eq_p (list.car x) case {
      true_t => list.cdr
      false_t => cons_c (
        list.car
        list_remove_first (list.cdr x))
    }
  }
}


list_length_t : type
list_length_t = disj {
  [ zero_length_t
    succ_length_t ]
  list : list_t (t)
  length : nat_t
}

zero_length_t : type
zero_length_t = conj {
  list : list_t (t)
  list = null_c
  length : nat_t
  length = zero_c
}

succ_length_t : type
succ_length_t = conj {
  list : list_t (t)
  list = cons_c (x l)
  length : nat_t
  length = succ_c (n)
  prev : list_length_t (l n)
}


note {
  in prolog, we will have :
    append([], Succ, Succ).
    append([Car | Cdr], Succ, [Car | ResultCdr]):_
      append(Cdr, Succ, ResultCdr).
}


list_append_t : type
list_append_t = disj {
  [ zero_append_t
    succ_append_t ]
  (ante succ result) : list_t (t)
}

zero_append_t : type
zero_append_t = conj {
  (ante succ result) : list_t (t)
  ante = null_c
  result = succ
}

succ_append_t : type
succ_append_t = conj {
  (ante succ result) : list_t (t)
  prev : list_append_t (cdr succ result_cdr)
  ante = cons_c (car cdr)
  result = cons_c (car result_cdr)
}
