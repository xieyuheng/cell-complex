* [note] row v.s. col
- `row_trans`
  - If we view matrix as linear equations,
    `row_trans` does not change solution.
  - If we view matrix as linear map,
    `row_trans` does not change kernel of the map.
  - but `row_trans` can change the col_space
- `col_trans`
  - If we view matrix as col of bases,
    `col_trans` does not change the spanned space of the bases.
  - If we view matrix as linear map,
    `col_trans` does not change the image of the map.
  - `col_trans` can not change the col_space
* [note] mathematical structures is about reuse
- in our euclidean-space.ts
  `row_canonical_form` and `row_hermite_normal_form`
  are almost the same
- to factor out this sameness, and to reuse code
  we need to use matrix over principal ideal integral ring
- this is the main use of abstract mathematical structures
  it solve the main problem of compute science
  but the shame is that
  no programming languages allow us
  to formalize abstract mathematical structures intuitively
* euclidean-space
- smith normal form -- to calculate homology group
- `point_t`
- use euclidean-space to re-imp hackenbush
* optimize
- optimize frame_t and series_t by not using data_t
  but to use matrix_t and vector_t
* panel-data
- frame_t.act & series_t.trans
- data_t slice
* cell-complex
- homology group of cell-complex
  - we will need quotient of vector_space_t (abelian_group_t)
    because homology group = quo (ker (boun (n+1)), img (boun (n)))
- abelian_group_t
  - classification finite generated abelian_group_t
    is the same as normalization of integer matrix
  - quotient space is needed,
    quotient space == redefine `.eq`,
    to make `.eq` normalize-able,
    we can use yoneda embedding
- `hl.chain_t.boundary ()`
- presentation of groupoid is the same as 2-dim cell-complex
  - by which we can calculate homology group of groupoid
  - my first aim is to
    generalize this algebraic structure for 3-dim cell-complex
  - we also want to study group representation
    i.e. find matrix group iso to given group
- glob_t
- ht.chain_t
  - `.boundary ()`
  - `.as_group ()` -- formalize presentation of group
  - `.as_groupoid ()` -- presentation of groupoid with `ht.chain_t`
  - abelianization of `ht.chain_t` to get homology theory
    abelianization 时如何获得定向 ?
  - `.glue ()`
    我们所要处理的代数结构中的元素是 ht.chain_t
    这在于
    元素是有类型的 (或者说是有边界的)
    我们的代数结构类似於 groupoid 而不是 group
    元素之间的复合不是简单地左右相乘
    而是 沿着边界 glue
    - 我们可以从 presentation of a groupoid 入手
      研究 groupoid 对 ht.chain_t 的需要
      也就是说
      1. 放宽对元素联通性的要求
      2. 丰富 compose 为 glue
- 2-dim manifold classification -- zip of john conway
- [refine API] auto compatible in morphism_builder_t
- bounfold_check
- groupoid of 2-dim cell-complex
  - `as_groupoid ()`
  - what is special about manifold's groupoid
- higher_groupoid_t
- cell_check -- is im_dic_compatible_p enough ?
- can we encode cell-complex by graph ?
  - what is "encode something by graph" ?
    with graph label ?
- product_complex_t
- quotient_complex_t -- self-gluing
- vertex_figure_t -- 3 dim
- pure_complex_t
  an n-dimensional complex is said to be pure
  if each k cell (k < n) is a face of at least one n-dimensional cell
- by the boundary of a pure n-dimensional cell
  we mean the totality of (n - 1)-cell
  which are incident with an odd number n-cells
- boundary operator
  - the boundary of the boundary of a cell_complex_t should be zero
    even if the cell_complex_t is not a bounfold_t
* geometry
- quaternion
- clifford-algebra
- polytope
  - a set of n >= 0 points is affinely independent
    if its affine hull has dimension n − 1,
    that is, if every proper subset has a smaller affine hull.
* combinatorial-game
- use go to test game tree searching
- why the games of logic seem like one-player game
- fol -- game semantics of first order logic
- cl -- game semantics of constructive logic
- aristotle (lukasiewicz) -> de morgan -> peirce
- dots-and-boxes
- go
- martin-gardner
- (paper) investigations into game semantics of logic
- surreal -- the theory of surreal number
  - theory about two-player normal-ending game
* cicada
- reuse js syntax
  the syntax of js is enough
  we only need to do the following extensions
  - `<f> (<field> = <object>)`
    function call with named field
  - `f (a) (b)` == `f (a, b)`
    auto currying
  - no `,` in function call
    maybe we need to limit the use of infix notation
  - use babel api to handle the syntax
- compile to js with runtime type information
  - game semantics
  - { type: { field: <type> }, field: <value> }
* dance
- 3 circle dance
- 4 circle dance
* principle about subclass
- we need a principle for the use of subclass,
  and the simplest principle is "do not use subclass".
