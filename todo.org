- try cell-complex--no-id.ts
  to simplify the API of cell_complex_t building
------
- 2-dim manifold classification -- zip of john conway
- classification of regular polytope
- holding implements until finite element method and PDE
- example usages of higher order incidence relation
- graph.ts with geometry
- geometry of convex polytope
  - example of give topological structure geometry
- algebra of cell-complex
  - check equality proof
  - the game of equality
- how to describe edge and face so they are easy to draw ?
- a generic way to specify geometry of cell-complex
* what knowledge is worth knowing ?
- topological and geometrical modeling
  - mesh
    - polytopal-complex
    - blender
  - clifford algebra
- physics simulation
  - differential equation & difference equation
  - finite element method -- PDE
  - direction field -- ODE
* the way to cicada language
- do not start from a "well designed" type theory
- start from the way I want to do formalize
- implement it and fix it by examples
- form a type theory at the end
* mesh
- to give geometry to cell-complex, we can
  1. generate mesh for cell-complex
  2. use affine variety of algebraic geometry
* polytope
- fourier-motzkin elimination
- simplify inequalities
- double description method
* num
- projection matrix for 1-dim subspace
  - rank one matrix
  - P.mul (P) .eq (P)
  - P.transpose () .eq (P)
- projection matrix for m-dim subspace
  - subspace represented by A
    - columns are column vectors of the subspace
  - P = A.mul (A.transpose () .mul (A) .inv ()) .mul (A.transpose ())
    - P.mul (P) .eq (P)
    - P.transpose () .eq (P)
- normal equation
- num.matrix_t.positive_definite_p ()
- abstract/order.ts -- for num.ts, for polytope.ts
- use num.ts to re-imp hackenbush
* mathematical structures
- ring.cs substructure and ideal_t
- order.ts -- lattice_t, poset_t, total_t, heyting_algebra_t
* graph
- reuse cell_complex_t -- by `graph_t.as_cell_complex ()`
- find cycles of graph by spanning tree's complement edges
  - homology of general graph
* int
- linear diophantine equations with mod -- finite field
* euclid
- .diag => .main_diag
- .diag .set_diag
- convert invariant_factors to elementary_divisors
- primary_decomposition -- [rank, [[p0, n0], [p1, n1], ...]]
- chinese_remainder_theorem
* dots-and-boxes
* hackenbush
- with editor
* computational-science
- stiffness matrix
- circulant matrix
* polynomial
- polynomial.ts -- symbolic algebra
* optimize
- optimize frame_t and series_t by not using data_t
  but to use matrix_t and vector_t
* panel-data
- frame_t.act & series_t.trans
- data_t slice
* homology
- what is the meaning of 1 torsion_coefficients ?
* homotopy
- presentation of groupoid is the same as 2-dim cell-complex
  - by which we can calculate homology group of groupoid
  - my first aim is to
    generalize this algebraic structure for 3-dim cell-complex
  - we also want to study group representation
    i.e. find matrix group iso to given group
- groupoid of 2-dim cell-complex
  - `as_groupoid ()`
  - what is special about manifold's groupoid
- glob_t
- ht.chain_t
  - `.boundary ()`
  - `.as_group ()` -- formalize presentation of group
  - `.as_groupoid ()` -- presentation of groupoid with `ht.chain_t`
  - abelianization of `ht.chain_t` to get homology theory
    abelianization 时如何获得定向 ?
  - `.glue ()`
    我们所要处理的代数结构中的元素是 ht.chain_t
    这在于
    元素是有类型的 (或者说是有边界的)
    我们的代数结构类似於 groupoid 而不是 group
    元素之间的复合不是简单地左右相乘
    而是 沿着边界 glue
    - 我们可以从 presentation of a groupoid 入手
      研究 groupoid 对 ht.chain_t 的需要
      也就是说
      1. 放宽对元素联通性的要求
      2. 丰富 compose 为 glue
- higher_groupoid_t
* cell-complex
- we can fully encode the information of cell-complex
  by cell-valued incidence matrixes,
  - we can specialize cells for each dimension,
    for examples:
    - +1,-1 (2-dim rotation) for [2-dim, 1-dim] incidence relation
    - 2-dim rotation for [3-dim, 2-dim] incidence relation
    - 3-dim rotation for [4-dim, 3-dim] incidence relation
- how about adjacency matrix between higher order elements ?
- [refine API] auto compatible in morphism_builder_t
- bounfold_check
- cell_check -- is im_dic_compatible_p enough ?
- can we encode cell-complex by graph ?
  - what is "encode something by graph" ?
    with graph label ?
- product_complex_t
- quotient_complex_t -- self-gluing
- vertex_figure_t -- 3 dim
- pure_complex_t
  an n-dimensional complex is said to be pure
  if each k cell (k < n) is a face of at least one n-dimensional cell
- boundary operator
  - the boundary of the boundary of a cell_complex_t should be zero
    even if the cell_complex_t is not a bounfold_t
* polytopal-complex
- like cell-complex
  but without self adjacency
  which simplifies the data structure
- polytopal-complex can be used as basic data structure in meshing
* geometry
- quaternion
- clifford-algebra
* combinatorial-game
- use go to test game tree searching
- why the games of logic seem like one-player game
- fol -- game semantics of first order logic
- cl -- game semantics of constructive logic
- aristotle (lukasiewicz) -> de morgan -> peirce
- go
- martin-gardner
- (paper) investigations into game semantics of logic
- surreal -- the theory of surreal number
  - theory about two-player normal-ending game
* cicada-core
- compile to js with runtime type information
  - game semantics
  - { type: { field: <type> }, field: <value> }
* cicadascript
- reuse js syntax
  the syntax of js is enough
  we only need to do the following extensions
  - function call with named field
    `<f> (<field> = <object>)`
  - auto currying
    `f (a) (b)` == `f (a, b)`
  - no `,` in function call
    - maybe we need to limit the use of infix notation
    - maybe use newline as `,`
- use babel api to handle the syntax
* dance
- 3 circle dance
- 4 circle dance
