#+title: Normalization by Evaluation

* [note] info

  - Checking Dependent Types
    with Normalization by Evaluation: A Tutorial

  - by David Thrane Christiansen

  - http://davidchristiansen.dk/tutorials/nbe

* 1 Evaluating Untyped lambda-Calculus

  - Writing an evaluator requires the following steps:
    - Identify the values that are to be the result of evaluation
    - Figure out which expressions become values immediately,
      and which require computation
    - Implement `classes` for the values,
      and use function for computation

*** 1.2 The Evaluator

    - A closure packages an expression
      that has not yet been evaluated

      with the run-time environment
      in which the expression was created.

      Here, closures always represent expressions with a variable
      that will be instantiated with a value,
      so these closures additionally have the `name` field.

    - The evaluator consists of two procedures

      - `exp.eval (env)`
        evaluates an expression in a run-time environment that
        provides values for its free variables,

      - `closure.apply (arg)`
        for applying the value of a function
        to the value of its argument

* 2 Generating Fresh Names

  - Normalization requires generating fresh names
    to avoid conflicting variable names.

* 3 Normalizing Untyped λ-Calculus

*** 3.1 Normal Forms

    - <exp> ::= <id> | (lambda (<id>) <exp>) | (<exp> <exp>)

    - equivalence relation of lambda terms.

      - alpha-equivalence:
        consistently renaming bound variables
        doesn’t change the meaning of an expression

      - beta-equivalence:
        applying a lambda-expression to an argument
        is equal to the result of the application

    - both rules are equations, which means that
      they can be applied anywhere in an expression
      and that they can be read both from left to right
      and from right to left.

    - When we have a collection of equations over syntax,
      the syntax can be seen as divided into various "buckets"
      where each expression in a bucket
      is αβ-equivalent to all the others in its bucket.

    - One way to check whether two expressions are in the same bucket
      is to assign each bucket a representative expression
      and provide a way to find the bucket representative
      for any given expression.

    - Then, if two expressions are in the same bucket,
      they will have the same representative.
      This canonical representative is referred to as a `normal form`.

    - Here, we adopt the convention that normal forms are those
      that contain no reducible expressions, or redexes,
      which is to say that there are no lambda-expressions
      directly applied to an argument.

    - Because α-equivalence is easier to check than β-equivalence,
      most people consider normal forms with respect to the β-rule only,
      and then use α-equivalence when comparing β-normal forms.

*** 3.2 Finding Normal Forms

    - When reducing under lambda,
      there will also be variables that
      do not have a value in the environment.
      To handle these cases,
      we need values that represent `neutral expressions`.

    - A neutral expression is an expression that
      we are not yet able to reduce to a value,
      because information such as
      the value of an argument to a function is not yet known.

    - In this language, there are two neutral expressions:
      variables that do not yet have a value,
      and applications where the function position is neutral.

    - <norm> ::= <neu> | (lambda (<id>) <norm>)
      <neu> ::= <id> | (<neu> <norm>)

* 5 Bidirectional Type Checking

  - Bidirectional type checking is a technique
    for making type systems syntax-directed
    that adds only a minimal annotation burden.

  - Typically, only the top level of an expression
    or any explicit redexes need to be annotated.

  - Additionally, bidirectional type checking provides guidance
    for the appropriate places to insert checks
    of type equality or subsumption.

*** 5.2 Checking Types

    - When writing a bidirectional type checker,
      the first step is to classify the expressions
      into introduction and elimination forms.

    - The introduction forms, also called constructors,
      allow members of a type to be created,
      while the eliminators expose the information
      inside of the constructors to computation.

    - In this section,
      the constructor of the `->` type is `lambda`
      and the constructors of `Nat` are `zero` and `add1`.
      The eliminators are function application and `rec`.

    - Under bidirectional type checking,
      the type system is split into two modes:
      in checking mode, an expression is
      analyzed against a known type to see if it fits,
      while in synthesis mode,
      a type is derived directly from an expression.

    - Each expression for which a type can be synthesized
      can be checked against a given type
      by performing the synthesis
      and then comparing the synthesized type to the desired type.

    - This is where subsumption
      or some other nontrivial type equality check can be inserted.

    - Additionally, type annotations (here, written e∈A)
      allow an expression that can be checked
      to be used where synthesis is required.

    - Usually, introduction forms have checking rules,
      while elimination forms admit synthesis.

* 6 Typed Normalization by Evaluation

*** 6.2 The Evaluator

    - Just as in Normalizing Untyped λ-Calculus,
      normalization consists of evaluation followed by reading back.

      Here, introduction and elimination rules for natural numbers are included.

    - The evaluator works in essentially the same way
      as the evaluator for untyped normalization.

      - Constructor expressions become values,

      - while eliminators delegate to helpers that

        - either compute the right answer
          when the target is a value,

        - or construct larger neutral terms
          when the target is neutral.

*** 6.3 Typed Read-Back

    - In untyped normalization by evaluation,
      values were examined to determine how to read them back.

      In typed NbE, however,
      each type can specify its own notion of equality,
      and thus the syntax of its normal forms.

      Therefore, reading back is now recursive
      on the structure of the type
      rather than the structure of the value.

* 7 A Tiny Piece of Pie

*** 7.1 The Language

***** 7.1.1 Identifiers

***** 7.1.2 Program α-equivalence

*** 7.2 Values and Normalization

***** 7.2.1 The Values

***** 7.2.2 Neutral Expressions

***** 7.2.3 Normal Forms

*** 7.3 Definitions and Dependent Types

***** 7.3.1 The Evaluator

***** 7.3.2 Eliminators

***** 7.3.3 Reading Back

*** 7.4 Type Checking

***** 7.4.1 The Type Checker

***** 7.4.2 Type Checking with Definitions

*** 7.5 Projects
