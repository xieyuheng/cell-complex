#+title: prelude -- leveless
- why we need levels ?
* [todo-stack]

  - avoid the use of `...`
  - no with-details -- to simplify expression syntax

* [note]

*** product-type and sum-type

    |              | literal syntax | inhabit             |
    |--------------+----------------+---------------------|
    | product-type | [<type> ...]   | [<data> ...]        |
    | sum-type     | + (<type> ...) | <data> : <type> ... |

*** conj-type, disj-type and heir-type

    |           | definition syntax                |
    |-----------+----------------------------------|
    | conj-type | conj { ... }                     |
    | disj-type | disj { [<sub-type> ...] ... }    |
    | heir-type | heir { [<super-type> ...>] ... } |

***** conj-type

      - it bound to a named type-constructor for the conj-type
        and specify a record with named and typed fields

      - a conj-type is a partly inhabited record

      - for example :
        cons-t (t)
        cons-c (car cdr)

***** constructor call syntax

      - call-with-order :
        <name>-c (<data> ...)

      - call-with-field-name :
        <name>-c {<field> = <data> ...}

***** disj-type

      - it bound to a named type-constructor for the disj-type
        and specify a list of fields

      - sub-type-relation
        <disj-type> :> <sub-type>

      - type-constructor of each sub-types
        must include these fields and types

      - each data of any of its sub-types
        will inhabit the disj-type

***** heir-type

      - it bound to a named type-constructor for the heir-type
        and specify a list of fields

      - sub-type-relation
        <heir-type> <: <super-type>

      - an heir-type includes its super-types records

      - each data of the heir-type
        will also inhabit all its super-types

***** sub-type-relation

      - `c1 <: c2` means c1 inherit c2 's fields,
        thus c1 is more special then c2,
        because c1 has more interface functions than c2.

      - whatever data inhabits c1 also inhabits c2.

*** :: -- implicit arguments

    - in arguments :
      - the value of the argument will be inferred.
      - use call-with-field-name syntax to give explicit value.

    - in return values :
      - the value must be constructed by the function.
        but normal function call syntax will not return the value.
      - use explicit `with-details` to get all details.

*** eqv-relation-t of eqv-t

    - eqv-relation-t of eqv-t
      is proved by the rules of unification
      or the rules of substitution

* void

*** void-t

    #+begin_src cicada
    void-t : type
    void-t = disj { [] }
    #+end_src

*** absurd

    #+begin_src cicada
    absurd : (void-t) -> t
    #+end_src

* unit

*** unit-t

    #+begin_src cicada
    unit-t : type
    unit-t = conj {}
    #+end_src

*** unit

    #+begin_src cicada
    unit : (a) -> unit-t
    unit (a) = unit-c
    #+end_src

* bool

*** bool-t

    #+begin_src cicada
    bool-t : type
    bool-t = disj {
      [ true-t
        false-t ]
    }

    true-t : type
    true-t = conj {}

    false-t : type
    false-t = conj {}
    #+end_src

* eqv

*** eqv-t

    #+begin_src cicada
    eqv-t : type
    eqv-t = conj {
      (lhs rhs) : t
      lhs = rhs
    }
    #+end_src

*** eqv-apply

    #+begin_src cicada
    eqv-apply : (
      fun : (a) -> b
      eqv-t (x y)
    ) -> eqv-t (fun (x) fun (y))
    eqv-apply (- -) = eqv-c
    #+end_src

*** eqv-swap

    #+begin_src cicada
    eqv-swap : (eqv-t (x y)) -> eqv-t (y x)
    eqv-swap (-) = eqv-c
    #+end_src

*** eqv-compose

    #+begin_src cicada
    eqv-compose : (eqv-t (x y) eqv-t (y z)) -> eqv-t (x z)
    eqv-compose (- -) = eqv-c
    #+end_src

* nat

*** nat-t

    #+begin_src cicada
    nat-t : type
    nat-t = disj {
      [ zero-t
        succ-t ]
    }

    zero-t : type
    zero-t = conj {}

    succ-t : type
    succ-t = conj {
      prev : nat-t
    }
    #+end_src

*** nat-add

    #+begin_src cicada
    nat-add : (nat-t nat-t) -> nat-t
    nat-add (x y) = {
      x case {
        zero-t -- y
        succ-t -- succ-c (nat-add (x.prev y))
      }
    }
    #+end_src

*** nat-mul

    #+begin_src cicada
    nat-mul : (nat-t nat-t) -> nat-t
    nat-mul (x y) = {
      x case {
        zero-t -- zero-c
        succ-t -- nat-add (y nat-mul (x.prev y))
      }
    }
    #+end_src

*** nat-factorial

    #+begin_src cicada
    nat-factorial : (nat-t) -> nat-t
    nat-factorial (x) = {
      x case {
        zero-t -- succ-c (zero-c)
        succ-t -- nat-mul (x nat-factorial (x.prev))
      }
    }
    #+end_src

*** nat-even-p

    #+begin_src cicada
    nat-even-p : (nat-t) -> bool-t
    nat-even-p (x) = {
      x case {
        zero-t -- true-c
        succ-t -- x.prev case {
          zero-t -- false-c
          succ-t -- nat-even-p (x.prev.prev)
        }
      }
    }
    #+end_src

*** nat-even-t

    #+begin_src cicada
    nat-even-t : type
    nat-even-t = disj {
      [ zero-even-t
        even-plus-two-even-t ]
      nat : nat-t
    }

    zero-even-t : type
    zero-even-t = conj {
      nat : nat-t
      nat = zero-c
    }

    even-plus-two-even-t : type
    even-plus-two-even-t = conj {
      nat : nat-t
      prev : nat-even-t (m)
      nat = succ-c (succ-c (m))
    }
    #+end_src

*** two-even

    #+begin_src cicada
    two-even : nat-even-t (succ-c (succ-c (zero-c)))
    two-even = even-plus-two-even-c (zero-even-c)
    #+end_src

*** nat-add-associative

    #+begin_src cicada
    nat-add-associative : ((x y z) : nat-t)
      -> eqv-t (
           nat-add (nat-add (x y) z)
           nat-add (x nat-add (y z)))
    nat-add-associative (x y z) = {
      x case {
        zero-t -- eqv-c
        succ-t -- eqv-apply (
          succ-c nat-add-associative (x.prev y z))
      }
    }
    #+end_src

*** nat-add-commutative

    #+begin_src cicada
    nat-add-commutative : ((x y) : nat-t)
      -> eqv-t (
           nat-add (x y)
           nat-add (y x))
    nat-add-commutative (x y) = x case {
      zero-t -- nat-add-zero-commutative (y)
      succ-t -- eqv-compose (
        eqv-apply (succ-c nat-add-commutative (x.prev y))
        nat-add-succ-commutative (y x.prev))
    }
    #+end_src

*** nat-add-zero-commutative

    #+begin_src cicada
    nat-add-zero-commutative : (x : nat-t)
      -> eqv-t (
           nat-add (zero-c x)
           nat-add (x zero-c))
    nat-add-zero-commutative (x) = {
      x case {
        zero-t -- eqv-c
        succ-t -- eqv-apply (
          succ-c nat-add-zero-commutative (x.prev))
      }
    }
    #+end_src

*** [note] about the game of eqv-t

    #+begin_src cicada
    note {
      to make it easier to prove eqv-t
      I want to be able to reduce
      1. the eqv-t to be proved
      2. the eqv-c constructing

      in `x case succ-t` of the above example

      the eqv-t to be proved is
      eqv-t (
        nat-add (zero-c x) >= x
        nat-add (x zero-c) >= succ-c (nat-add (x.prev zero-c))
      )

      the eqv-c constructing is
      eqv-apply (succ-c nat-add-zero-commutative (x.prev)) :
      eqv-t (
        succ-c (nat-add (zero-c x.prev)) >= succ-c (x.prev) >= x
        succ-c (nat-add (x.prev zero-c))
      )

      only after many `>=`s
      do we explicitly see that eqv-c actually fulfill eqv-t

      maybe we need let the verifier to explicitly choose
      which reduction to perform

      otherwise we would need to prove reductions converge to
      unique normal form (or unifiable form)

      maybe we'd better internalize eqv-t
      instead of defining it as a type in our language

      advantage of doing so is that it works
      not only for the concrete class eqv-t
      but also for any equivalent relations

      it might be viewed as an example of
      defining a little game of eqv-t in our language of games
    }
    #+end_src

*** nat-add-succ-commutative-1

    #+begin_src cicada
    nat-add-succ-commutative-1 : ((x y) : nat-t)
      -> eqv-t (
           nat-add (succ-c (x) y)
           succ-c (nat-add (x y)))
    nat-add-succ-commutative-1 (x y) = {
      x case {
        zero-t -- eqv-c
        succ-t -- eqv-apply (
          succ-c nat-add-succ-commutative-1 (x.prev y))
      }
    }
    #+end_src

*** nat-add-succ-commutative-2

    #+begin_src cicada
    nat-add-succ-commutative-2 : ((x y) : nat-t)
      -> eqv-t (
           nat-add (y succ-c (x))
           succ-c (nat-add (x y)))
    nat-add-succ-commutative-2 (x y) = {
      x case {
        zero-t -- eqv-c
        succ-t -- eqv-apply (
          succ-c nat-add-succ-commutative-2 (x.prev y))
      }
    }
    #+end_src

* list

*** list-t

    #+begin_src cicada
    list-t : type
    list-t = disj {
      [ null-t
        cons-t ]
      t : type
    }

    null-t : type
    null-t = conj {
      t : type
    }

    cons-t : type
    cons-t = conj {
      t : type
      car : t
      cdr : list-t (t)
    }
    #+end_src

*** list-length

    #+begin_src cicada
    list-length : (list-t (t)) -> nat-t
    list-length (list) = {
      list case {
        null-t -- zero-c
        cons-t -- succ-c (list-length (list.cdr))
      }
    }
    #+end_src

*** list-append

    #+begin_src cicada
    list-append : (list-t (t) list-t (t)) -> list-t (t)
    list-append (ante succ) = {
      ante case {
        null-t -- succ
        cons-t -- cons-c (ante.car list-append (ante.cdr succ))
      }
    }
    #+end_src

*** list-map

    #+begin_src cicada
    list-map : ((a) -> b list-t (a)) -> list-t (b)
    list-map (fun list) = {
      list case {
        null-t -- list
        cons-t -- cons-c (
          fun (list.car)
          list-map (fun list.cdr))
      }
    }
    #+end_src

*** list-remove-first

    #+begin_src cicada
    list-remove-first : (t list-t (t)) -> list-t (t)
    list-remove-first (x list) = {
      list case {
        null-t -- list
        cons-t -- eq-p (list.car x) case {
          true-t -- list.cdr
          false-t -- cons-c (
            list.car
            list-remove-first (list.cdr x))
        }
      }
    }
    #+end_src

*** list-length-t

    #+begin_src cicada
    list-length-t : type
    list-length-t = disj {
      [ zero-length-t
        succ-length-t ]
      list : list-t (t)
      length : nat-t
    }

    zero-length-t : type
    zero-length-t = conj {
      list : list-t (t)
      list = null-c
      length : nat-t
      length = zero-c
    }

    succ-length-t : type
    succ-length-t = conj {
      list : list-t (t)
      list = cons-c (x l)
      length : nat-t
      length = succ-c (n)
      prev : list-length-t (l n)
    }
    #+end_src

*** [note] `append` in prolog

    #+begin_src cicada
    note {
      in prolog, we will have :
        append([], Succ, Succ).
        append([Car | Cdr], Succ, [Car | ResultCdr]):-
          append(Cdr, Succ, ResultCdr).
    }
    #+end_src

*** list-append-t

    #+begin_src cicada
    list-append-t : type
    list-append-t = disj {
      [ zero-append-t
        succ-append-t ]
      (ante succ result) : list-t (t)
    }

    zero-append-t : type
    zero-append-t = conj {
      (ante succ result) : list-t (t)
      ante = null-c
      result = succ
    }

    succ-append-t : type
    succ-append-t = conj {
      (ante succ result) : list-t (t)
      prev : list-append-t (cdr succ result-cdr)
      ante = cons-c (car cdr)
      result = cons-c (car result-cdr)
    }
    #+end_src

* vect

*** vect-t

    #+begin_src cicada
    vect-t : type
    vect-t = disj {
      [ null-vect-t
        cons-vect-t ]
      t : type
      length : nat-t
    }

    null-vect-t : type
    null-vect-t = conj {
      t : type
      length : nat-t
      length = zero-c
    }

    cons-vect-t : type
    cons-vect-t = conj {
      t : type
      length : nat-t
      car : t
      cdr : vect-t (t n)
      length = succ-c (n)
    }
    #+end_src

*** vect-append

    #+begin_src cicada
    vect-append : (
      vect-t (t m)
      vect-t (t n)
    ) -> vect-t (t nat-add (m n))
    vect-append (ante succ) = {
      ante case {
        null-vect-t -- succ
        cons-vect-t -- cons-vect-c (
          ante.car vect-append (ante.cdr succ))
      }
    }
    #+end_src

*** vect-map

    #+begin_src cicada
    vect-map : ((a) -> b vect-t (a n)) -> vect-t (a n)
    vect-map (fun list) = {
      list case {
        null-vect-t -- list
        cons-vect-t -- cons-vect-c (
          fun (list.car) vect-map (fun list.cdr))
      }
    }
    #+end_src

* order

*** preorder-t

    #+begin_src cicada
    note {
      preorder is a thin category
      with at most one morphism from an object to another.
    }

    preorder-t : type
    preorder-t = conj {
      element-t : type

      pre-t : (element-t element-t)
        -> type

      pre-reflexive : (a :: element-t)
        -> pre-t (a a)

      pre-transitive : (pre-t (a b) pre-t (b c))
        -> pre-t (a c)
    }
    #+end_src

*** partial-order-t

    #+begin_src cicada
    partial-order-t : type
    partial-order-t = heir {
      [ preorder-t ]
      element-eqv-t : (element-t element-t)
        -> type

      pre-anti-symmetric : (pre-t (a b) pre-t (b a))
        -> element-eqv-t (a b)
    }
    #+end_src

*** eqv-relation-t

    #+begin_src cicada
    eqv-relation-t : type
    eqv-relation-t = heir {
      [ preorder-t ]
      pre-symmetric : (pre-t (a b)) -> pre-t (b a)
    }
    #+end_src

*** total-order-t

    #+begin_src cicada
    total-order-t : type
    total-order-t = heir {
      [ partial-order-t ]
      pre-connex : ((a b) : element-t)
        -> + (pre-t (a b) pre-t (b a))
    }
    #+end_src

* unique

*** unique-t

    #+begin_src cicada
    unique-t : type
    unique-t = conj {
      t : type
      value : t
      underlying-eqv-t : (t t) -> type
      condition-t : (t) -> type

      unique-proof :
        [condition-t (value)
         (another : t condition-t (another))
           -> underlying-eqv-t (value another)]
    }
    #+end_src

*** [todo] (unique)

    #+begin_src cicada
    (unique <t>
     of <value>
     under <underlying-eqv-t>
     such-that <condition-t>) = macro {
       unique-t
         t = <t>
         value = <value>
         underlying-eqv-t = <underlying-eqv-t>
         condition-t = <condition-t>
     }
    #+end_src

* category

*** category-t

    #+begin_src cicada
    category-t : type
    category-t = conj {
      object-t : type
      arrow-t : (object-t object-t) -> type
      arrow-eqv-t : (arrow-t (a b) arrow-t (a b))
        -> type

      identity : (a :: object-t) -> arrow-t (a a)

      compose : (arrow-t (a b) arrow-t (b c)) -> arrow-t (a c)

      identity-neutral-left : (f : arrow-t (a b))
        -> arrow-eqv-t (f compose (identity f))

      identity-neutral-right : (f : arrow-t (a b))
        -> arrow-eqv-t (f compose (f identity))

      compose-associative : (
        f : arrow-t (a b)
        g : arrow-t (b c)
        h : arrow-t (c d)
      ) -> arrow-eqv-t (
        compose (f compose (g h))
        compose (compose (f g) h))

      arrow-eqv-relation : ((a b) :: object-t)
        -> eqv-relation-t (
             element-t = arrow-t (a b)
             pre-t = arrow-eqv-t)
    }
    #+end_src

*** basic relation

***** category-t.isomorphic-t

      #+begin_src cicada
      category-t.isomorphic-t : type
      category-t.isomorphic-t = conj {
        (lhs rhs) : object-t
        iso : arrow-t (lhs rhs)
        inv : arrow-t (rhs lhs)
        iso-inv-identity :
          arrow-eqv-t (compose (iso inv) identity)
        inv-iso-identity :
          arrow-eqv-t (compose (inv iso) identity)
      }
      #+end_src

*** universal construction

***** category-t.initial-t

      #+begin_src cicada
      category-t.initial-t : type
      category-t.initial-t = conj {
        initial : object-t
        factorizer : (cand : object-t)
          -> factor : arrow-t (initial cand)
      }
      #+end_src

***** category-t.terminal-t

      #+begin_src cicada
      category-t.terminal-t : type
      category-t.terminal-t = heir {
        [ terminal-candidate-t ]
        terminal : object-t
        factorizer : (cand : object-t)
          -> factor : arrow-t (cand terminal)
      }
      #+end_src

***** category-t.product-t

      #+begin_src cicada
      category-t.product-candidate-t : type
      category-t.product-candidate-t = conj {
        fst : object-t
        snd : object-t
        product : object-t
        fst-projection : arrow-t (product fst)
        snd-projection : arrow-t (product snd)
      }

      category-t.product-t : type
      category-t.product-t = heir {
        [ product-candidate-t ]
        factorizer : (cand : product-candidate-t (fst snd))
          -> factor : arrow-t (cand.product product)
        unique-factor : (cand : product-candidate-t (fst snd))
          -> unique factorizer (cand)
             of arrow-t (cand.product product)
             under arrow-eqv-t
             such-that
               arrow-eqv-t (
                 cand.fst-projection
                 compose (factor fst-projection))
               arrow-eqv-t (
                 cand.snd-projection
                 compose (factor snd-projection))
      }
      #+end_src

***** category-t.sum-t

      #+begin_src cicada
      category-t.sum-candidate-t : type
      category-t.sum-candidate-t = conj {
        fst : object-t
        snd : object-t
        sum : object-t
        fst-injection : arrow-t (fst sum)
        snd-injection : arrow-t (snd sum)
      }

      category-t.sum-t : type
      category-t.sum-t = heir {
        [ sum-candidate-t ]
        factorizer : (cand : sum-candidate-t (fst snd))
          -> factor : arrow-t (sum cand.sum)
        unique-factor : (cand : sum-candidate-t (fst snd))
          -> unique factorizer (cand)
             of arrow-t (sum cand.sum)
             under arrow-eqv-t
             such-that
               arrow-eqv-t (
                 cand.fst-injection
                 compose (fst-injection factor))
               arrow-eqv-t (
                 cand.snd-injection
                 compose (snd-injection factor))
      }
      #+end_src

*** other structure as category

***** preorder.as-category

      #+begin_src cicada
      note {
        to view a preorder as a category
        we simple view all arrow of the same type as eqv
      }

      preorder.as-category : category-t
      preorder.as-category = category-c {
        object-t = element-t

        arrow-t = pre-t

        arrow-eqv-t (- -) = unit-t

        identity = pre-reflexive

        compose = pre-transitive

        identity-neutral-left (-) = unit-c

        identity-neutral-right (-) = unit-c

        compose-associative (- - -) = unit-c
      }
      #+end_src

*** build new category from old category

***** category-t.opposite

      #+begin_src cicada
      category-t.opposite : category-t
      category-t.opposite = category-c {
        object-t = this.object-t

        arrow-t : (object-t object-t)
          -> type
        arrow-t (a b) = this.arrow-t (b a)

        arrow-eqv-t : (this.arrow-t (b a) this.arrow-t (b a))
          -> type
        arrow-eqv-t = this.arrow-eqv-t

        identity : (a :: object-t)
          -> arrow-t (a a)
        identity = this.identity

        compose : (this.arrow-t (b a) this.arrow-t (c b))
          -> this.arrow-t (c a)
        compose (f g) = this.compose (g f)

        identity-neutral-left : (f : this.arrow-t (b a))
          -> arrow-eqv-t (f this.compose (f identity))
        identity-neutral-left = this.identity-neutral-right

        identity-neutral-right : (f : this.arrow-t (b a))
          -> arrow-eqv-t (f this.compose (identity f))
        identity-neutral-right = this.identity-neutral-left

        compose-associative : (
          f : this.arrow-t (b a)
          g : this.arrow-t (c b)
          h : this.arrow-t (d c)
        ) -> arrow-eqv-t (
          this.compose (this.compose (h g) f)
          this.compose (h this.compose (g f)))
        compose-associative (f g h) = {
          this.arrow-eqv-relation.pre-symmetric (
            this.compose-associative (h g f))
        }
      }
      #+end_src

***** category-product

      #+begin_src cicada
      category-product : (category-t category-t) -> category-t
      category-product (#1 #2) = category-c {
        object-t = [#1.object-t #2.object-t]

        arrow-t (a b) =
          [#1.arrow-t (a.1 b.1)
           #2.arrow-t (a.2 b.2)]

        arrow-eqv-t (lhs rhs) =
          [#1.arrow-eqv-t (lhs.1 rhs.1)
           #2.arrow-eqv-t (lhs.2 rhs.2)]

        identity =
          [#1.identity
           #2.identity]

        compose (f g) =
          [#1.compose (f.1 g.1)
           #2.compose (f.2 g.2)]

        identity-neutral-left (f) =
          [#1.identity-neutral-left (f.1)
           #2.identity-neutral-left (f.2)]

        identity-neutral-right (f) =
          [#1.identity-neutral-right (f.1)
           #2.identity-neutral-right (f.2)]

        compose-associative (f g h) =
          [#1.compose-associative (f.1 g.1 h.1)
           #2.compose-associative (f.2 g.2 h.2)]
      }
      #+end_src

* product-closed-category

*** product-closed-category-t

    #+begin_src cicada
    product-closed-category-t : type
    product-closed-category-t = heir {
      [ category-t ]
      product : ((a b) : object-t)
        -> p : object-t
           product-relation :: product-t (a b p)
    }
    #+end_src

*** ><><>< product-closed-category-t.product-arrow

    #+begin_src cicada
    product-closed-category-t.product-arrow : (
      arrow-t (a b)
      arrow-t (c d)
    ) -> arrow-t (product (a c) product (b d))
    product-closed-category-t.product-arrow (f g) = {
      with-details product (a c)
        p <= product-relation
      with-details product (b d)
        q <= product-relation
      q.factorizer (
        product-candidate-c {
          fst = b
          snd = d
          product = product (a c)
          fst-projection = compose (p.fst-projection f)
          snd-projection = compose (p.fst-projection g)
        })
    }
    #+end_src

*** product-closed-category-t.exponential-t

    #+begin_src cicada
    product-closed-category-t.exponential-candidate-t : type
    product-closed-category-t.exponential-candidate-t = conj {
      ante : object-t
      succ : object-t
      exponential : object-t
      eval : arrow-t (product (exponential ante) succ)
    }

    category-t.exponential-t : type
    category-t.exponential-t = heir {
      [ exponential-candidate-t ]
      factorizer : (cand : exponential-candidate-t (ante succ))
        -> factor : arrow-t (cand.exponential exponential)
      unique-factor : (cand : exponential-candidate-t (ante succ))
        -> unique factorizer (cand)
           of arrow-t (cand.exponential exponential)
           under arrow-eqv-t
           such-that
             arrow-eqv-t (
               cand.eval
               compose (eval product-arrow (factor identity)))
    }
    #+end_src

* [todo] cartesian-closed-category

* void-category

*** void-arrow-t

    #+begin_src cicada
    void-arrow-t : type
    void-arrow-t = conj {
      (ante succ) : void-t
    }
    #+end_src

*** void-arrow-eqv-t

    #+begin_src cicada
    void-arrow-eqv-t : type
    void-arrow-eqv-t = conj {
      (lhs rhs) : void-arrow-t (a b)
    }
    #+end_src

*** void-category

    #+begin_src cicada
    void-category : category-t
    void-category = category-c {
      object-t = void-t
      arrow-t = void-arrow-t
      arrow-eqv-t = void-arrow-eqv-t

      identity : (a :: void-t)
        -> void-arrow-t (a a)
      identity (-) = void-arrow-c

      compose (- -) = void-arrow-c

      identity-neutral-left : (f : void-arrow-t (a b))
        -> void-arrow-eqv-t (f void-arrow-c)
      identity-neutral-left (-) = void-arrow-eqv-c

      identity-neutral-right : (f : void-arrow-t (a b))
        -> void-arrow-eqv-t (f void-arrow-c)
      identity-neutral-right (-) = void-arrow-eqv-c

      compose-associative : (
        f : void-arrow-t (a b)
        g : void-arrow-t (b c)
        h : void-arrow-t (c d)
      ) -> void-arrow-eqv-t (void-arrow-eqv-c void-arrow-eqv-c)
      compose-associative (- - -) = void-arrow-eqv-c
    }
    #+end_src

* graph-t

*** graph-t

    #+begin_src cicada
    note {
      different between graph and category is that
      composing [linking] two edges does not give you edge but path.
    }

    graph-t : type
    graph-t = conj {
      node-t : type
      edge-t : (node-t node-t) -> type
    }
    #+end_src

*** graph.path-t

    #+begin_src cicada
    graph-t.path-t : type
    graph-t.path-t = data
      :> [node-path-t
          edge-path-t
          link-path-t] {
      (start end) : node-t
    }

    graph-t.node-path-t : type
    graph-t.node-path-t = conj {
      (start end) : node-t
      node : node-t
      start = node
      end = node
    }

    graph-t.edge-path-t : type
    graph-t.edge-path-t = conj {
      (start end) : node-t
      edge : edge-t (start end)
    }

    graph-t.link-path-t : type
    graph-t.link-path-t = conj {
      (start end) : node-t
      first : path-t (start middle)
      next : path-t (middle end)
    }
    #+end_src

*** graph-t.path-eqv-t

    #+begin_src cicada
    graph-t.path-eqv-t : type
    graph-t.path-eqv-t = data
      :> [refl-path-eqv-t
          node-left-path-eqv-t
          node-right-path-eqv-t
          associative-path-eqv-t] {
      (lhs rhs) : path-t (a b)
    }

    graph-t.refl-path-eqv-t : type
    graph-t.refl-path-eqv-t = conj {
      (lhs rhs) : path-t (a b)
      p : path-t (a b)
      lhs = p
      lhs = p
    }

    graph-t.node-left-path-eqv-t : type
    graph-t.node-left-path-eqv-t = conj {
      (lhs rhs) : path-t (a b)
      p : path-t (a b)
      lhs = p
      rhs = link-path-c (node-path-c (a) p)
    }

    graph-t.node-right-path-eqv-t : type
    graph-t.node-right-path-eqv-t = conj {
      (lhs rhs) : path-t (a b)
      p : path-t (a b)
      lhs = p
      rhs = link-path-c (p node-path-c (b))
    }

    graph-t.associative-path-eqv-t : type
    graph-t.associative-path-eqv-t = conj {
      (lhs rhs) : path-t (a b)
      p : path-t (a b)
      q : path-t (b c)
      r : path-t (c d)
      lhs = link-path-c (p link-path-c (q r))
      rhs = link-path-c (link-path-c (p q) r)
    }
    #+end_src

*** graph-t.as-free-category

    #+begin_src cicada
    graph-t.as-free-category : category-t
    graph-t.as-free-category = category-c {
      object-t = node-t
      arrow-t = path-t
      arrow-eqv-t = path-eqv-t

      identity : (a :: node-t)
        -> path-t (a a)
      identity = node-path-c (a)

      compose = link-path-c

      identity-neutral-left : (f : path-t (a b))
        -> path-eqv-t (f link-path-c (node-path-c (a) f))
      identity-neutral-left = node-left-path-eqv-c

      identity-neutral-right : (f : path-t (a b))
        -> path-eqv-t (f link-path-c (f node-path-c (b)))
      identity-neutral-right = node-right-path-eqv-c

      compose-associative : (
        f : path-t (a b)
        g : path-t (b c)
        h : path-t (c d)
      ) -> path-eqv-t (
        link-path-c (f link-path-c (g h))
        link-path-c (link-path-c (f g) h))
      compose-associative = associative-path-eqv-c
    }
    #+end_src

* nat-order-category

*** nat-lteq-t

    #+begin_src cicada
    nat-lteq-t : type
    nat-lteq-t = disj {
      [ zero-lteq-t
        succ-lteq-t ]
      (l r) : nat-t
    }


    zero-lteq-t : type
    zero-lteq-t = conj {
      (l r) : nat-t
      l = zero-c
    }

    succ-lteq-t : type
    succ-lteq-t = conj {
      (l r) : nat-t
      prev : nat-lteq-t (x y)
      l = succ-c (x)
      r = succ-c (y)
    }
    #+end_src

*** nat-non-negative

    #+begin_src cicada
    nat-non-negative : (n : nat-t) -> nat-lteq-t (zero-c n)
    nat-non-negative = zero-lteq-c
    #+end_src

*** nat-lteq-reflexive

    #+begin_src cicada
    nat-lteq-reflexive : (n : nat-t) -> nat-lteq-t (n n)
    nat-lteq-reflexive (n) = {
      n case {
        zero-t -- zero-lteq-c
        succ-t -- succ-lteq-c (nat-lteq-reflexive (n.prev))
      }
    }
    #+end_src

*** nat-lteq-transitive

    #+begin_src cicada
    nat-lteq-transitive : (
      nat-lteq-t (a b)
      nat-lteq-t (b c)
    ) -> nat-lteq-t (a c)
    nat-lteq-transitive (x y) = {
      x case {
        zero-lteq-t -- zero-lteq-c
        succ-lteq-t -- succ-lteq-c (nat-lteq-transitive (x.prev y.prev))
      }
    }
    #+end_src

*** nat-lt-t

    #+begin_src cicada
    nat-lt-t : (nat-t nat-t) -> type
    nat-lt-t (l r) = nat-lteq-t (succ-c (l) r)
    #+end_src

*** nat-archimedean-property

    #+begin_src cicada
    nat-archimedean-property : (x : nat-t)
      -> [y : nat-t, nat-lt-t (x y)]
    nat-archimedean-property x =
      [succ-c (x) nat-lteq-reflexive (succ-c (x))]
    #+end_src

*** nat-order-category

    #+begin_src cicada
    nat-order-category : category-t
    nat-order-category = category-c {
      object-t = nat-t
      arrow-t = nat-lteq-t
      arrow-eqv-t = eqv-t

      identity : (a :: nat-t)
        -> nat-lteq-t (a a)
      identity = nat-lteq-reflexive (a)

      compose = nat-lteq-transitive

      identity-neutral-left (x) = {
        x case {
          zero-lteq-t -- eqv-c
          succ-lteq-t -- eqv-apply (
            succ-lteq-c identity-neutral-left (x.prev))
        }
      }

      identity-neutral-righ (x) = {
        x case {
          zero-lteq-t -- eqv-c
          succ-lteq-t -- eqv-apply (
            succ-lteq-c identity-neutral-righ (x.prev))
        }
      }

      compose-associative (f g h) = {
        [f g h] case {
          [zero-lteq-t - -] -- eqv-c
          [succ-lteq-t succ-lteq-t succ-lteq-t] --
            eqv-apply (
              succ-lteq-c
              compose-associative (f.prev g.prev h.prev))
        }
      }
    }
    #+end_src

* groupoid

*** groupoid-t

    #+begin_src cicada
    groupoid-t : type
    groupoid-t = heir {
      [ category-t ]
      inverse : (f : arrow-t (a b)) -> isomorphic-t (a b f)
    }
    #+end_src

* [todo] nat-total-order

* monoid

*** monoid-t

    #+begin_src cicada
    monoid-t : type
    monoid-t = conj {
      element-t : type

      element-eqv-t : (element-t element-t)
        -> type

      unit : element-t

      product : (element-t element-t)
        -> element-t

      unit-neutral-left : (a : element-t)
        -> element-eqv-t (product (a unit) a)

      unit-neutral-right : (a : element-t)
        -> element-eqv-t (product (unit a) a)

      product-associative : (
        a : element-t
        b : element-t
        c : element-t
      ) -> element-eqv-t (
        product (a product (b c))
        product (product (a b) c))
    }
    #+end_src

*** monoid-t.as-category

    #+begin_src cicada
    monoid-t.as-category : category-t
    monoid-t.as-category = category-c {
      object-t = unit-t
      arrow-t (- -) = element-t
      arrow-eqv-t = element-eqv-t
      identity = unit
      compose = product
      identity-neutral-left = unit-neutral-left
      identity-neutral-right = unit-neutral-right
      compose-associative = product-associative
    }
    #+end_src

* [todo] group

* [todo] abelian-group

* [todo] ring

* [todo] field

* [todo] vector-space

* [todo] limit

* container

*** container-t

    #+begin_src cicada
    note {
      endofunctor of set-category
    }

    container-t : type
    container-t = conj {
      fun-t : (type) -> type
      map : ((a) -> b fun-t (a)) -> fun-t (b)
    }
    #+end_src

*** list-container

    #+begin_src cicada
    list-container : container-t
    list-container = container-c {
      fun-t = list-t
      map (fun list) = {
        list case {
          null-t -- null-c
          cons-t -- cons-c (fun (list.car) map (fun list.cdr))
        }
      }
    }
    #+end_src

* const

*** const-t

    #+begin_src cicada
    const-t : type
    const-t = conj {
      (c a) : type
      value : c
    }
    #+end_src

*** const-container

    #+begin_src cicada
    const-container : (type) -> container-t
    const-container (c) = container-c {
      fun-t = const-t (c)

      map : ((a) -> b const-t (c a)) -> const-t (c b)
      map (- x) = x
    }
    #+end_src

* monad

*** monad-t

    #+begin_src cicada
    monad-t : type
    monad-t = heir {
      [ container-t ]
      pure : (t) -> fun-t (t)
      bind : (fun-t (a), (a) -> fun-t (b)) -> fun-t (b)
    }
    #+end_src

*** monad-t.compose

    #+begin_src cicada
    monad-t.compose : (
      (a) -> fun-t (b)
      (b) -> fun-t (c)
    ) -> (a) -> fun-t (c)
    monad-t.compose (f g) = (a) => {
      bind (f (a) g)
    }
    #+end_src

*** monad-t.flatten

    #+begin_src cicada
    monad-t.flatten : (fun-t (fun-t (a)))
      -> fun-t (a)
    monad-t.flatten (m) = bind (m () => {})
    #+end_src

*** list-monad

    #+begin_src cicada
    list-monad : monad-t
    list-monad = monad-c {
      pure (x) = cons-c (x null-c)
      bind (list fun) = {
        list case {
          null-t -- null-c
          cons-t -- list-append (fun (list.car) bind (list.cdr fun))
        }
      }
    }
    #+end_src

* maybe

*** maybe-t

    #+begin_src cicada
    maybe-t : type
    maybe-t = disj {
      [ none-t
        just-t ]
      t : type
    }

    none-t : type
    none-t = conj {
      t : type
    }

    just-t : type
    just-t = conj {
      t : type
      value : t
    }
    #+end_src

*** maybe-container

    #+begin_src cicada
    maybe-container : container-t
    maybe-container = container-c {
      fun-t = maybe-t
      map (fun maybe) = {
        maybe case {
          none-t -- none-c
          just-t -- just-c (fun (maybe.value))
        }
      }
    }
    #+end_src

*** maybe-monad

    #+begin_src cicada
    maybe-monad : monad-t
    maybe-monad = monad-c {
      pure = just-c
      bind (maybe fun) = {
        maybe case {
          none-t -- none-c
          just-t -- fun (maybe.value)
        }
      }
    }
    #+end_src

* state

*** state-t

    #+begin_src cicada
    state-t : (type type) -> type
    state-t (s a) = (s) -> [s a]
    #+end_src

*** state-monad

    #+begin_src cicada
    state-monad : (type) -> monad-t
    state-monad (s) = monad-c {
      fun-t = state-t (s)

      map : ((a) -> b, state-t (s a))
        -> state-t (s b)
      map : (
        (a) -> b
        (s) -> [s a]
      ) -> (s) -> [s b]
      map (f m) = (s) => {
        [1st (m (s))
         f (2nd (m (s)))]
      }

      pure : (t) -> state-t (s t)
      pure : (t) -> (s) -> [s t]
      pure (v) = (s) => {
        [s v]
      }

      bind : (fun-t (a) (a)) -> fun-t (b) -> fun-t (b)
      bind : (state-t (s a) (a) -> state-t (s b)) -> state-t (s b)
      bind : (
        (s) -> [s a]
        (a) -> (s) -> [s b]
      ) -> (s) -> [s b]
      bind (m f) = (s) => {
        f (2st (m (s))) (1st (m (s)))
      }
    }
    #+end_src

* tree

*** tree-t

    #+begin_src cicada
    tree-t : type
    tree-t = disj {
      [ leaf-t
        branch-t ]
      t : type
    }

    leaf-t : type
    leaf-t = conj {
      t : type
      value : t
    }

    branch-t : type
    branch-t = conj {
      t : type
      (left right) : tree-t (t)
    }
    #+end_src

*** tree-container

    #+begin_src cicada
    tree-container : container-t
    tree-container = container-c {
      fun-t = tree-t
      map (fun tree) = {
        tree case {
          leaf-t -- leaf-c (fun (tree.value))
          branch-t -- branch-c (
            map (fun tree.left)
            map (fun tree.right))
        }
      }
    }
    #+end_src

*** tree-zip

    #+begin_src cicada
    tree-zip : (tree-t (a), tree-t (b))
      -> maybe-t (tree-t ([a b]))
    tree-zip (x y) = {
      [x y] case {
        [leaf-t leaf-t] --
          pure (leaf-c ([x.value y.value]))
        [branch-t branch-t] -- do {
          left <= tree-zip (x.left y.left)
          right <= tree-zip (x.right y.right)
          pure (branch-c (left right))
        }
        [- -] -- none-c
      }
    }
    #+end_src

*** tree-numbering

    #+begin_src cicada
    tree-numbering : (tree-t (t))
      -> state-t (nat-t tree-t (nat-t))
    tree-numbering (tree) = {
      tree case {
        leaf-t -- (n) => {
          [nat-inc (n) leaf-c (n)]
        }
        branch-t -- do {
          left <= tree-numbering (tree.left)
          right <= tree-numbering (tree.right)
          pure (branch-c (left right))
        }
      }
    }
    #+end_src

* int

*** [todo] int-t

*** [todo] mod-t

*** gcd-t

    #+begin_src cicada
    gcd-t : type
    gcd-t = disj {
      [ zero-gcd-t
        mod-gcd-t ]
      (x y d) : int-t
    }

    zero-gcd-t : type
    zero-gcd-t = conj {
      (x y d) : int-t
      y = zero-c
      x = d
    }

    mod-gcd-t : type
    mod-gcd-t = conj {
      (x y d) : int-t
      gcd : gcd-t (z x d)
      mod : mod-t (z x y)
    }
    #+end_src

* set-category

*** [todo] set-t

    #+begin_src cicada
    note {
      The set theory of Errett Bishop.
    }

    set-t : type
    set-t = conj {
      element-t : type
      eqv-t : -> element-t element-t -> type
    }
    #+end_src

*** set-morphism-t

    #+begin_src cicada
    set-morphism-t : type
    set-morphism-t = conj {
      ante : type
      succ : type

      morphism : (ante) -> succ
    }
    #+end_src

*** set-morphism-eqv-t

    #+begin_src cicada
    set-morphism-eqv-t : type
    set-morphism-eqv-t = conj {
      lhs : set-morphism-t (a b)
      rhs : set-morphism-t (a b)

      morphism-eqv : (x) : a
        -> eqv-t (lhs.morphism (x) rhs.morphism (x))
    }
    #+end_src

*** set-category

    #+begin_src cicada
    set-category : category-t
    set-category = category-c {
      object-t = type

      arrow-t (a b) = set-morphism-t (a b)

      arrow-eqv-t (lhs rhs) = set-morphism-eqv-t (lhs rhs)

      identity = set-morphism-c {
        morphism = nop
      }

      compose (f g) = set-morphism-c {
        morphism = function-compose (f.morphism g.morphism)
      }

      identity-neutral-left (-) = set-morphism-eqv-c {
        morphism-eqv (-) = eqv-c
      }

      identity-neutral-right (-) = set-morphism-eqv-c {
        morphism-eqv (-) = eqv-c
      }

      compose-associative (- - -) = set-morphism-eqv-c {
        morphism-eqv (-) = eqv-c
      }
    }
    #+end_src

* preorder-category

*** preorder-morphism-t

    #+begin_src cicada
    preorder-morphism-t : type
    preorder-morphism-t = conj {
      ante : preorder-t
      succ : preorder-t

      morphism : (ante.element-t) -> succ.element-t

      morphism-respect-pre-relation : (ante.pre-t (x y))
        -> succ.pre-t (morphism (x) morphism (y))
    }
    #+end_src

*** preorder-morphism-eqv-t

    #+begin_src cicada
    preorder-morphism-eqv-t : type
    preorder-morphism-eqv-t = conj {
      lhs : preorder-morphism-t (a b)
      rhs : preorder-morphism-t (a b)

      morphism-eqv : (x : a.element-t)
        -> eqv-t (lhs.morphism (x) rhs.morphism (x))
    }
    #+end_src

*** preorder-category

    #+begin_src cicada
    preorder-category : category-t
    preorder-category = category-c {
      object-t : type
      object-t = preorder-t

      arrow-t : (preorder-t preorder-t) -> type
      arrow-t (a b) = preorder-morphism-t (a b)

      arrow-eqv-t : (
        preorder-morphism-t (a b)
        preorder-morphism-t (a b)
      ) -> type
      arrow-eqv-t (lhs rhs) = preorder-morphism-eqv-t (lhs rhs)

      identity : (a :: preorder-t)
        -> preorder-morphism-t (a a)
      identity = preorder-morphism-c {
        morphism = nop
        morphism-respect-pre-relation = nop
      }

      compose : (
        preorder-morphism-t (a b)
        preorder-morphism-t (b c)
      ) -> preorder-morphism-t (a c)
      compose (f g) = preorder-morphism-c {
        morphism = function-compose (f.morphism g.morphism)
        morphism-respect-pre-relation = {
          function-compose (
            f.morphism-respect-pre-relation
            g.morphism-respect-pre-relation)
        }
      }

      identity-neutral-left (f) = preorder-morphism-eqv-c {
        morphism-eqv (-) = eqv-c
      }

      identity-neutral-right (f) = preorder-morphism-eqv-c {
        morphism-eqv (-) = eqv-c
      }

      compose-associative (f g h) = preorder-morphism-eqv-c {
        morphism-eqv (-) = eqv-c
      }
    }
    #+end_src

* category-category

*** functor-t

    - a functor between two categories is a natural-construction
      of the structure of [ante : category-t]
      in the structure of [succ : category-t]

    #+begin_src cicada
    functor-t : type
    functor-t = conj {
      ante : category-t
      succ : category-t

      object-map : (ante.object-t)
        -> succ.object-t

      arrow-map : (ante.arrow-t (a b))
        -> succ.arrow-t (object-map (a) object-map (b))

      arrow-map-respect-compose : (
        f : ante.arrow-t (a b)
        g : ante.arrow-t (b c)
      ) -> succ.arrow-eqv-t (
        arrow-map (ante.compose (f g))
        succ.compose (arrow-map (f) arrow-map (g)))

      arrow-map-respect-identity : (a :: ante.object-t)
        -> succ.arrow-eqv-t (
             arrow-map (ante.identity (a))
             succ.identity (object-map (a)))
    }
    #+end_src

*** natural-transformation-t

    - a natural-transformation is a level up map
      which maps objects to arrows and arrows to squares.

    #+begin_src cicada
    natural-transformation-t : type
    natural-transformation-t = conj {
      lhs : functor-t (ante succ)
      rhs : functor-t (ante succ)

      ante succ :: object-t

      component : (a : ante.object-t)
        -> succ.arrow-t (lhs.object-map (a) rhs.object-map (a))

      transformation : (f : ante.arrow-t (a b))
        -> succ.arrow-eqv-t (
             succ.compose (component (a) rhs.arrow-map (f))
             succ.compose (lhs.arrow-map (f) component (b)))
    }
    #+end_src

*** natural-isomorphism-t

    #+begin_src cicada
    natural-isomorphism-t : type
    natural-isomorphism-t = heir {
      [ natural-transformation-t ]
      isomorphic-component : (a : ante.object-t)
        -> succ.isomorphic-t (iso = component (a))
    }
    #+end_src

*** [todo] category-category

    #+begin_src cicada
    category-category : category-t
    category-category = category-c {
      object-t : category-t
      object-t = category-t

      arrow-t : (category-t category-t)
        -> type
      arrow-t (a b) = functor-t (a b)

      arrow-eqv-t : (functor-t (a b) functor-t (a b))
        -> type
      arrow-eqv-t (lhs rhs) = natural-isomorphism-t (lhs rhs)

      identity : (a :: category-t) -> functor-t (a a)
      identity = functor-c {
        ante = a
        succ = a
        [todo]
      }

      compose : (functor-t (a b) functor-t (b c))
        -> functor-t (a c)
      compose =
        [todo]


      identity-neutral-left : (f : functor-t (a b))
        -> natural-isomorphism-t (f compose (identity f))
      identity-neutral-left =
        [todo]

      identity-neutral-right : (f : functor-t (a b))
        -> natural-isomorphism-t (f compose (f identity))
      identity-neutral-right =
        [todo]

      compose-associative : (
        f : functor-t (a b)
        g : functor-t (b c)
        h : functor-t (c d)
      ) -> natural-isomorphism-t (
        compose (f compose (g h))
        compose (compose (f g) h))
      compose-associative =
        [todo]
    }
    #+end_src
