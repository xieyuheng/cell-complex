#+property: tangle src/main/scala/cicada.scala
#+title: cicada

* [todo]

  - clear object model

  - flexible syntax -- this means we give up the mexp approach
    - a model for ast
    - a lib for parsing -- grammar to ast

  - function type -- exp_t v.s. obj_t

* [note]

  - x -
    should we use implicit-curry for function type ?
    should we use implicit-curry for data- and type-constructor ?

* id_t

  #+begin_src scala
  class id_t {}
  #+end_src

* name_t

  #+begin_src scala
  class name_t (
    str: String,
  ) {}
  #+end_src

* body_t

  #+begin_src scala
  class body_t {
    var map: Map [name_t, obj_t] = Map ()
  }
  #+end_src

* [todo] exp_t

  #+begin_src scala
  trait exp_t {}
  #+end_src

* obj_t

  #+begin_src scala
  trait obj_t {}
  #+end_src

* var_obj_t

  #+begin_src scala
  class var_obj_t (
    id: id_t,
    name: name_t,
    t: obj_t,
  ) extends obj_t {}
  #+end_src

* disj_obj_t

  #+begin_src scala
  class disj_obj_t (
    name: name_t,
    sub_type_names: List [name_t],
    body: body_t,
  ) extends obj_t {}
  #+end_src

* conj_obj_t

  #+begin_src scala
  class conj_obj_t (
    name: name_t,
    body: body_t,
  ) extends obj_t {}
  #+end_src

* data_obj_t

  #+begin_src scala
  class data_obj_t (
    name: name_t,
    body: body_t,
  ) extends obj_t {}
  #+end_src

* tt_obj_t

  #+begin_src scala
  class tt_obj_t (
  ) extends obj_t {}
  #+end_src

* [todo] lambda_obj_t

* module_obj_t

  #+begin_src scala
  class module_obj_t extends obj_t {
    var body = new body_t
    def define (name: name_t, obj: obj_t) {
      body.map += (name -> obj)
    }
  }
  #+end_src

* main

  #+begin_src scala
  object main {
    def main (args: Array [String]) = {
      var module = new module_obj_t
      module.define (new name_t ("type"), new tt_obj_t)
      module.define (new name_t ("type2"), new tt_obj_t)
      println (module.body)
    }
  }
  #+end_src
